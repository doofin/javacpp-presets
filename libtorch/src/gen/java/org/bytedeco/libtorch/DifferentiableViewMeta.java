// Targeted by JavaCPP version 1.5.4-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.libtorch;

import org.bytedeco.javacpp.Loader;
import org.bytedeco.javacpp.Pointer;
import org.bytedeco.javacpp.annotation.*;


/** Unified function to handle error checking when rebase happens
 *  indirect=true means that the caller is not doing the inplace, but the inplace happened
 *  somewhere else. */

@Namespace("torch::autograd") @NoOffset @Properties(inherit = org.bytedeco.libtorch.presets.libtorch.class)
public class DifferentiableViewMeta extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DifferentiableViewMeta(Pointer p) { super(p); }

  /** The base {@code Variable} (never a view). */
  public native @ByRef @Cast("torch::autograd::Variable*") Pointer base_(); public native DifferentiableViewMeta base_(Pointer setter);

  /** The value of the version_counter at the time grad_fn was created. The
   *  grad_fn field is stale if attr_version !=
   *  version_counter.current_version(). */
  public native @Cast("uint32_t") int attr_version(); public native DifferentiableViewMeta attr_version(int setter);

  /** By default we use as_strided to recover views which is more efficient.
   *  view_fn is only saved when as_strided is not supported.
   *  If view_fn has value, we use it to recover views in backward. */
  public native @ByRef @Cast("c10::optional<std::function<at::Tensor(const at::Tensor&)> >*") Pointer view_fn_(); public native DifferentiableViewMeta view_fn_(Pointer setter);

  public native @Cast("torch::autograd::CreationMeta") byte creation_meta(); public native DifferentiableViewMeta creation_meta(byte setter);

  public native @Cast("bool") boolean requires_grad();

  public native @Cast("bool") boolean has_view_fn();

  public native @ByVal @Cast("std::function<at::Tensor(const at::Tensor&)>*") Pointer view_fn();

  public DifferentiableViewMeta(@Cast("at::TensorImpl*") Pointer self_impl, @ByVal @Cast("torch::autograd::Variable*") Pointer base, @ByVal @Cast("c10::optional<std::function<at::Tensor(const at::Tensor&)> >*") Pointer view_fn,
                           @Cast("torch::autograd::CreationMeta") byte creation_meta/*=torch::autograd::CreationMeta::DEFAULT*/) { super((Pointer)null); allocate(self_impl, base, view_fn, creation_meta); }
  private native void allocate(@Cast("at::TensorImpl*") Pointer self_impl, @ByVal @Cast("torch::autograd::Variable*") Pointer base, @ByVal @Cast("c10::optional<std::function<at::Tensor(const at::Tensor&)> >*") Pointer view_fn,
                           @Cast("torch::autograd::CreationMeta") byte creation_meta/*=torch::autograd::CreationMeta::DEFAULT*/);
  public DifferentiableViewMeta(@Cast("at::TensorImpl*") Pointer self_impl, @ByVal @Cast("torch::autograd::Variable*") Pointer base, @ByVal @Cast("c10::optional<std::function<at::Tensor(const at::Tensor&)> >*") Pointer view_fn) { super((Pointer)null); allocate(self_impl, base, view_fn); }
  private native void allocate(@Cast("at::TensorImpl*") Pointer self_impl, @ByVal @Cast("torch::autograd::Variable*") Pointer base, @ByVal @Cast("c10::optional<std::function<at::Tensor(const at::Tensor&)> >*") Pointer view_fn);
}
