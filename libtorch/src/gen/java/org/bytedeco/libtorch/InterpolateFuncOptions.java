// Targeted by JavaCPP version 1.5.4-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.libtorch;

import org.bytedeco.javacpp.Loader;
import org.bytedeco.javacpp.Pointer;
import org.bytedeco.javacpp.annotation.Namespace;
import org.bytedeco.javacpp.annotation.Properties;


/** Options for {@code torch::nn::functional::interpolate}.
 * 
 *  Example:
 *  <pre>{@code
 *  namespace F = torch::nn::functional;
 *  F::interpolate(input, F::InterpolateFuncOptions().size(std::vector<int64_t>({4})).mode(torch::kNearest));
 *  }</pre> */
@Namespace("torch::nn::functional") @Properties(inherit = org.bytedeco.libtorch.presets.libtorch.class)
public class InterpolateFuncOptions extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public InterpolateFuncOptions() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public InterpolateFuncOptions(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InterpolateFuncOptions(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public InterpolateFuncOptions position(long position) {
        return (InterpolateFuncOptions)super.position(position);
    }
    @Override public InterpolateFuncOptions getPointer(long i) {
        return new InterpolateFuncOptions(this).position(position + i);
    }


  /** output spatial sizes. */

  /** multiplier for spatial size. */

  /** the upsampling algorithm: one of "nearest", "linear", "bilinear",
   *  "bicubic", "trilinear", and "area". Default: "nearest" */

  /** Geometrically, we consider the pixels of the input and output as squares
   *  rather than points. If set to "True", the input and output tensors are
   *  aligned by the center points of their corner pixels, preserving the values
   *  at the corner pixels. If set to "False", the input and output tensors
   *  are aligned by the corner points of their corner pixels, and the
   *  interpolation uses edge value padding for out-of-boundary values, making
   *  this operation *independent* of input size when :attr:{@code scale_factor} is
   *  kept the same. This only has an effect when :attr:{@code mode} is "linear",
   *  "bilinear", "bicubic" or "trilinear". Default: "False" */

  /** recompute the scale_factor for use in the
   *  interpolation calculation.  When {@code scale_factor} is passed as a parameter, it is used
   *  to compute the {@code output_size}.  If {@code recompute_scale_factor} is {@code true} or not specified,
   *  a new {@code scale_factor} will be computed based on the output and input sizes for use in the
   *  interpolation computation (i.e. the computation will be identical to if the computed
   *  {@code output_size} were passed-in explicitly).  Otherwise, the passed-in {@code scale_factor} will
   *  be used in the interpolation computation.  Note that when {@code scale_factor} is floating-point,
   *  the recomputed scale_factor may differ from the one passed in due to rounding and precision
   *  issues. */
}
