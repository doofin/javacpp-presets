// Targeted by JavaCPP version 1.5.4-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.libtorch;

import org.bytedeco.javacpp.DoublePointer;
import org.bytedeco.javacpp.FloatPointer;
import org.bytedeco.javacpp.Loader;
import org.bytedeco.javacpp.Pointer;
import org.bytedeco.javacpp.annotation.*;

import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;

import static org.bytedeco.libtorch.global.libtorch.ScalarType;


/**
 * Scalar represents a 0-dimensional tensor which contains a single element.
 * Unlike a tensor, numeric literals (in C++) are implicitly convertible to
 * Scalar (which is why, for example, we provide both add(Tensor) and
 * add(Scalar) overloads for many operations). It may also be used in
 * circumstances where you statically know a tensor is 0-dim and single size,
 * but don't know its type.
 */
@Namespace("c10") @NoOffset @Properties(inherit = org.bytedeco.libtorch.presets.libtorch.class)
public class Scalar extends Pointer {
    static { Loader.load(); }

  public Scalar() { super((Pointer)null); allocate(); }
  private native void allocate();

// #define DEFINE_IMPLICIT_CTOR(type, name)
//   Scalar(type vv) : Scalar(vv, true) { }

  public Scalar(@Cast("uint8_t") byte vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(@Cast("uint8_t") byte vv); 
  public Scalar(short vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(short vv); 
  public Scalar(int vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(int vv); 
  public Scalar(@Cast("int64_t") long vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(@Cast("int64_t") long vv); 
  public Scalar(float vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(float vv); 
  public Scalar(double vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(double vv);
  public Scalar(@ByVal @Cast("c10::complex<float>*") Pointer vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(@ByVal @Cast("c10::complex<float>*") Pointer vv);
  // TODO: remove the std::complex below
  public Scalar(@ByVal @Cast("std::complex<float>*") FloatPointer vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(@ByVal @Cast("std::complex<float>*") FloatPointer vv);
  public Scalar(@ByVal @Cast("std::complex<float>*") FloatBuffer vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(@ByVal @Cast("std::complex<float>*") FloatBuffer vv);
  public Scalar(@ByVal @Cast("std::complex<float>*") float[] vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(@ByVal @Cast("std::complex<float>*") float[] vv);
  public Scalar(@ByVal @Cast("std::complex<double>*") DoublePointer vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(@ByVal @Cast("std::complex<double>*") DoublePointer vv);
  public Scalar(@ByVal @Cast("std::complex<double>*") DoubleBuffer vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(@ByVal @Cast("std::complex<double>*") DoubleBuffer vv);
  public Scalar(@ByVal @Cast("std::complex<double>*") double[] vv) { super((Pointer)null); allocate(vv); }
  private native void allocate(@ByVal @Cast("std::complex<double>*") double[] vv);

// #undef DEFINE_IMPLICIT_CTOR

  // Value* is both implicitly convertible to SymbolicVariable and bool which
  // causes ambiguosity error. Specialized constructor for bool resolves this
  // problem.

// #define DEFINE_ACCESSOR(type, name)
//   type to##name() const {
//     if (Tag::HAS_d == tag) {
//       return checked_convert<type, double>(v.d, #type);
//     } else if (Tag::HAS_z == tag) {
//       return checked_convert<type, c10::complex<double>>(
//           v.z, #type);
//     } if (Tag::HAS_b == tag) {
//       return checked_convert<type, bool>(v.i, #type);
//     } else {
//       return checked_convert<type, int64_t>(v.i, #type);
//     }
//   }

  // TODO: Support ComplexHalf accessor
  public native @Cast("uint8_t") byte toByte();
  public native byte toChar();
  public native short toShort();
  public native int toInt();
  public native @Cast("int64_t") long toLong();
  
  public native float toFloat();
  public native double toDouble();
  public native @ByVal @Cast("c10::complex<float>*") Pointer toComplexFloat();
  public native @ByVal @Cast("c10::complex<double>*") Pointer toComplexDouble();
  public native @Cast("bool") boolean toBool();
  

  // also support scalar.to<int64_t>();

// #undef DEFINE_ACCESSOR
  public native @Cast("bool") boolean isFloatingPoint();

  public native @Cast("bool") boolean isIntegral();
  public native @Cast("bool") boolean isIntegral(@Cast("bool") boolean includeBool);

  public native @Cast("bool") boolean isComplex();
  public native @Cast("bool") boolean isBoolean();

  public native @ByVal @Name("operator -") Scalar subtract();

  public native ScalarType type();
}
