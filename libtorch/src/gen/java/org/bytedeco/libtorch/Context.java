// Targeted by JavaCPP version 1.5.4-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.libtorch;

import org.bytedeco.javacpp.Loader;
import org.bytedeco.javacpp.Pointer;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.libtorch.global.libtorch.QEngine;


@Namespace("at") @NoOffset @Properties(inherit = org.bytedeco.libtorch.presets.libtorch.class)
public class Context extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Context(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Context(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Context position(long position) {
        return (Context)super.position(position);
    }
    @Override public Context getPointer(long i) {
        return new Context(this).position(position + i);
    }

  public Context() { super((Pointer)null); allocate(); }
  private native void allocate();

  public native @Const @ByRef Generator defaultGenerator(@ByVal Device device);
  public native @ByVal Device getDeviceFromPtr(Pointer data, @Cast("c10::DeviceType") short device_type);
  public native @Cast("bool") boolean isPinnedPtr(Pointer data);
  public native @Cast("bool") boolean hasOpenMP();
  public native @Cast("bool") boolean hasMKL();
  public native @Cast("bool") boolean hasLAPACK();
  public native @Cast("bool") boolean hasMKLDNN();
  public native @Cast("bool") boolean hasMAGMA();
  public native @Cast("bool") boolean hasCUDA();
  public native @Cast("bool") boolean hasHIP();
  public native @Cast("bool") boolean hasXLA();
  // defined in header so that getNonVariableType has ability to inline
  // call_once check. getNonVariableType is called fairly frequently
  public native THCState lazyInitCUDA();
  public native THHState lazyInitHIP();
  public native @Const @ByRef NVRTC getNVRTC();
  public native THCState getTHCState();
  public native THHState getTHHState();

  public native @Cast("bool") boolean setFlushDenormal(@Cast("bool") boolean on);

  // NB: This method is *purely* whether or not a user requested
  // that CuDNN was enabled, it doesn't actually say anything about
  // whether or not CuDNN is actually usable.  Use cudnn_is_acceptable
  // to test this instead
  public native @Cast("bool") boolean userEnabledCuDNN();
  public native void setUserEnabledCuDNN(@Cast("bool") boolean e);
  public native @Cast("bool") boolean userEnabledMkldnn();
  public native void setUserEnabledMkldnn(@Cast("bool") boolean e);
  public native @Cast("bool") boolean benchmarkCuDNN();
  public native void setBenchmarkCuDNN(@Cast("bool") boolean arg0);
  public native @Cast("bool") boolean deterministicCuDNN();
  public native void setDeterministicCuDNN(@Cast("bool") boolean arg0);
  public native @Cast("bool") boolean deterministic();
  public native void setDeterministic(@Cast("bool") boolean arg0);
  public native void alertNotDeterministic(@Cast("const c10::string_view*") @ByRef Pointer caller);
  public native @ByVal QEngine qEngine();
  public native void setQEngine(@ByVal QEngine e);
  public native @Const @ByRef QEngineVector supportedQEngines();
  public native @Cast("bool") boolean isXNNPACKAvailable();
  // This method is used to release the original weight after pre-packing.
  // It should be called once before loading/running the model.
  // NB: By default it is set to true for mobile builds.
  public native void setReleaseWeightsWhenPrepacking(@Cast("bool") boolean e);
  public native @Cast("bool") boolean releaseWeightsWhenPrepacking();
}
