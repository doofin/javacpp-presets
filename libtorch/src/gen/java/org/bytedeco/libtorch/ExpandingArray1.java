// Targeted by JavaCPP version 1.5.4-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.libtorch;

import org.bytedeco.javacpp.Loader;
import org.bytedeco.javacpp.Pointer;
import org.bytedeco.javacpp.annotation.*;


/** A utility class that accepts either a container of {@code D}-many values, or a
 *  single value, which is internally repeated {@code D} times. This is useful to
 *  represent parameters that are multidimensional, but often equally sized in
 *  all dimensions. For example, the kernel size of a 2D convolution has an {@code x}
 *  and {@code y} length, but {@code x} and {@code y} are often equal. In such a case you could
 *  just pass {@code 3} to an {@code ExpandingArray<2>} and it would "expand" to {@code {3, 3}}. */
@Name("torch::ExpandingArray<1>") @NoOffset @Properties(inherit = org.bytedeco.libtorch.presets.libtorch.class)
public class ExpandingArray1 extends Pointer {
    static { Loader.load(); }

  /** Constructs an {@code ExpandingArray} from an {@code initializer_list}. The extent of
   *  the length is checked against the {@code ExpandingArray}'s extent parameter {@code D}
   *  at runtime. */
  /*implicit*/

  /** Constructs an {@code ExpandingArray} from an {@code std::vector}. The extent of
   *  the length is checked against the {@code ExpandingArray}'s extent parameter {@code D}
   *  at runtime. */
  /*implicit*/ public ExpandingArray1(@StdVector T vec) { super((Pointer)null); allocate(vec); }
private native void allocate(@StdVector T vec);

  /** Constructs an {@code ExpandingArray} from an {@code at::ArrayRef}. The extent of
   *  the length is checked against the {@code ExpandingArray}'s extent parameter {@code D}
   *  at runtime. */
  /*implicit*/ public ExpandingArray1(@ByVal @Cast("at::ArrayRef<T>*") Pointer values) { super((Pointer)null); allocate(values); }
private native void allocate(@ByVal @Cast("at::ArrayRef<T>*") Pointer values);

  /** Constructs an {@code ExpandingArray} from a single value, which is repeated {@code D}
   *  times (where {@code D} is the extent parameter of the {@code ExpandingArray}). */
  /*implicit*/

  /** Constructs an {@code ExpandingArray} from a correctly sized {@code std::array}. */
  /*implicit*/

  /** Accesses the underlying {@code std::array}. */
  public native @Cast("std::array<T,1>*") @ByRef @Name("operator *") Pointer multiply();

  /** Accesses the underlying {@code std::array}. */

  /** Accesses the underlying {@code std::array}. */
  public native @Cast("std::array<T,1>*") @Name("operator ->") Pointer access();

  /** Accesses the underlying {@code std::array}. */

  /** Returns an {@code ArrayRef} to the underlying {@code std::array}. */
  public native @ByVal @Cast("at::ArrayRef<T>*") @Name("operator at::ArrayRef<T>") Pointer asPointer();

  /** Returns the extent of the {@code ExpandingArray}. */
  public native @Cast("size_t") @NoException long size();
}
